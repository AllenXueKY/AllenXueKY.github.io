<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>Spring学习day03（Spring中的AOP） | Allen Xue&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Allen Xue&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Allen Xue&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Spring学习day03（Spring中的AOP）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Allen Xue</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">March 18, 2020&nbsp;&nbsp;14:09:53</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/Java-EE/">Java_EE</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="一、AOP的相关概念"><a href="#一、AOP的相关概念" class="headerlink" title="一、AOP的相关概念"></a>一、AOP的相关概念</h2><h3 id="1、AOP概述"><a href="#1、AOP概述" class="headerlink" title="1、AOP概述"></a>1、AOP概述</h3><h4 id="（1）什么是AOP"><a href="#（1）什么是AOP" class="headerlink" title="（1）什么是AOP"></a>（1）什么是AOP</h4><p><strong>AOP：全称是Aspect Oriented Programming，即：面向切面编程。</strong><br><img src="/2020/03/18/Spring学习day03（Spring中的AOP）/1.png" alt="image"></p>
<ul>
<li>简单的说它就是<strong>把程序中重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有方法进行增强</strong>。</li>
</ul>
<h4 id="（2）AOP的作用及优势"><a href="#（2）AOP的作用及优势" class="headerlink" title="（2）AOP的作用及优势"></a>（2）AOP的作用及优势</h4><ul>
<li><strong>作用</strong>：<strong>在程序运行期间，不修改源码对已有方法进行增强。</strong></li>
<li><strong>优势</strong>：<ul>
<li><strong>减少重复代码</strong></li>
<li><strong>提高开发效率</strong></li>
<li><strong>维护方便</strong></li>
</ul>
</li>
</ul>
<h4 id="（3）AOP的实现方式"><a href="#（3）AOP的实现方式" class="headerlink" title="（3）AOP的实现方式"></a>（3）AOP的实现方式</h4><p><strong>使用动态代理技术</strong></p>
<h3 id="2、AOP的具体应用"><a href="#2、AOP的具体应用" class="headerlink" title="2、AOP的具体应用"></a>2、AOP的具体应用</h3><h4 id="（1）案例中问题"><a href="#（1）案例中问题" class="headerlink" title="（1）案例中问题"></a>（1）案例中问题</h4><p><strong>分析</strong> <em>上篇文章（Spring学习day02（基于注解的IOC配置、Spring整合Junit））<a href="https://blog.csdn.net/qq_34504626/article/details/104910295" target="_blank" rel="noopener">点击访问</a></em> 中的案例（这是之前写的账户信息增删改查例子）。 下面是客户的<strong>业务层实现类</strong>。（有问题，而且很严重）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 账户的业务层实现类</span><br><span class="line">*/</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    private IAccountDao accountDao;</span><br><span class="line">    public void setAccountDao(IAccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void saveAccount(Account account) throws SQLException &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void updateAccount(Account account) throws SQLException&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void deleteAccount(Integer accountId) throws SQLException&#123;</span><br><span class="line">        accountDao.delete(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Account findAccountById(Integer accountId) throws SQLException &#123;</span><br><span class="line">        return accountDao.findById(accountId);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Account&gt; findAllAccount() throws SQLException&#123;</span><br><span class="line">        return accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>打眼一看，这不就正常的增产改查有啥问题？其实不然</em>。</p>
<p><strong>所有的事务被自动控制了</strong>。换言之，<strong>在使用connection 对象时将自动提交设置为true</strong>即<code>setAutoCommit(true)</code>，这种方式控制事务，如果我们<strong>每次都执行一条sql语句，没有问题</strong>，但是如果业务方法一次要<strong>执行多条sql语句，这种方式就无法实现功能了</strong>。</p>
<p>如果现在，<strong>在业务层中多加入一个方法</strong>。</p>
<ul>
<li><p><strong>业务层接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 转账</span><br><span class="line">* @param sourceName</span><br><span class="line">* @param targetName</span><br><span class="line">* @param money</span><br><span class="line">*/</span><br><span class="line">void transfer(String sourceName,String targetName,Float money);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>业务层实现类</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void transfer(String sourceName, String targetName, Float money) &#123;</span><br><span class="line">    //根据名称查询两个账户信息</span><br><span class="line">    Account source = accountDao.findByName(sourceName);</span><br><span class="line">    Account target = accountDao.findByName(targetName);</span><br><span class="line">    //转出账户减钱，转入账户加钱</span><br><span class="line">    source.setMoney(source.getMoney()-money);</span><br><span class="line">    target.setMoney(target.getMoney()+money);</span><br><span class="line">    //更新两个账户</span><br><span class="line">    accountDao.update(source);</span><br><span class="line">    </span><br><span class="line">    int i=1/0; //模拟转账异常</span><br><span class="line">    </span><br><span class="line">    accountDao.update(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>当执行时，由于执行有异常，转账失败。但是因为<strong>每次执行持久层方法都是独立事务，导致无法实现事务控制（不符合事务的一致性）</strong>，你会发现：在执行完上述的转账操作，会抛出除数为零的异常，此时，肯定代表着转帐失败，但是查询数据库发现，有一个账户的钱已经转出去了，而另一个账户没有收到钱，这是非常严重的问题。<br><img src="/2020/03/18/Spring学习day03（Spring中的AOP）/5.png" alt="image"></p>
<h4 id="（2）问题的解决"><a href="#（2）问题的解决" class="headerlink" title="（2）问题的解决"></a>（2）问题的解决</h4><ul>
<li><p><strong>解决办法</strong>：<strong>让业务层来控制事务的提交和回滚。</strong></p>
</li>
<li><p><strong>改造后的业务层实现类</strong>：（<strong>此处没有使用spring的 IoC</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 账户的业务层实现类</span><br><span class="line">*/</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    private AccountDao accountDao = new AccountDaoImpl();</span><br><span class="line">    @Override</span><br><span class="line">    public void saveAccount(Account account) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TransactionManager.beginTransaction();</span><br><span class="line">            accountDao.save(account);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            TransactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            TransactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void updateAccount(Account account) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TransactionManager.beginTransaction();</span><br><span class="line">            accountDao.update(account);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            TransactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            TransactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void deleteAccount(Integer accountId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TransactionManager.beginTransaction();</span><br><span class="line">            accountDao.delete(accountId);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            TransactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            TransactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Account findAccountById(Integer accountId) &#123;</span><br><span class="line">        Account account = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            TransactionManager.beginTransaction();</span><br><span class="line">            account = accountDao.findById(accountId);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">            return account;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            TransactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            TransactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Account&gt; findAllAccount() &#123;</span><br><span class="line">    List&lt;Account&gt; accounts = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            TransactionManager.beginTransaction();</span><br><span class="line">            accounts = accountDao.findAll();</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">            return accounts;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            TransactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            TransactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void transfer(String sourceName, String targetName, Float money) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            TransactionManager.beginTransaction();</span><br><span class="line">            Account source = accountDao.findByName(sourceName);</span><br><span class="line">            Account target = accountDao.findByName(targetName);</span><br><span class="line">            source.setMoney(source.getMoney()-money);</span><br><span class="line">            target.setMoney(target.getMoney()+money);</span><br><span class="line">            accountDao.update(source);</span><br><span class="line">            </span><br><span class="line">            int i=1/0;</span><br><span class="line">            accountDao.update(target);</span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            TransactionManager.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            TransactionManager.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>TransactionManager类的代码</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 事务控制类</span><br><span class="line">*/</span><br><span class="line">public class TransactionManager &#123;</span><br><span class="line">    //定义一个 DBAssit</span><br><span class="line">    private static DBAssit dbAssit = new DBAssit(C3P0Utils.getDataSource(),true);</span><br><span class="line">    //开启事务</span><br><span class="line">    public static void beginTransaction() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().setAutoCommit(false);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //提交事务</span><br><span class="line">    public static void commit() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().commit();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //回滚事务</span><br><span class="line">    public static void rollback() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().rollback();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //释放资源</span><br><span class="line">    public static void release() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            dbAssit.releaseConnection();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="（3）新的问题"><a href="#（3）新的问题" class="headerlink" title="（3）新的问题"></a>（3）新的问题</h4><p>通过对业务层改造，已经<strong>可以实现事务控制了</strong>，但是由于我们添加了事务控制，也<strong>产生了一个新的问题</strong>：<br>业务层方法变得<strong>臃肿</strong>了，里面充斥着<strong>很多重复代码</strong>。并且<strong>业务层方法和事务控制方法耦合</strong>了。</p>
<p><em>试想一下，如果此时提交，回滚，释放资源中任何一个方法名变更，都需要修改业务层的代码，况且这还只是一个业务层实现类，而实际的项目中这种业务层实现类可能有十几个甚至几十个。</em></p>
<p>这个问题能不能解决呢？答案是可以解决，怎么解决呢？<strong>动态代理</strong></p>
<h4 id="（4）动态代理回顾"><a href="#（4）动态代理回顾" class="headerlink" title="（4）动态代理回顾"></a>（4）动态代理回顾</h4><h5 id="动态代理的特点"><a href="#动态代理的特点" class="headerlink" title="动态代理的特点"></a>动态代理的特点</h5><ul>
<li><strong>字节码随用随创建，随用随加载。</strong></li>
<li>它<strong>与静态代理的区别</strong>：因为静态代理是字节码一上来就创建好，并完成加载。</li>
<li><strong>装饰者模式</strong>就是<strong>静态代理</strong>的一种体现。</li>
</ul>
<h5 id="动态代理常用的有两种方式"><a href="#动态代理常用的有两种方式" class="headerlink" title="动态代理常用的有两种方式"></a>动态代理常用的有两种方式</h5><ul>
<li><strong>基于接口的动态代理</strong><ul>
<li><strong>提供者：JDK官方的Proxy类</strong></li>
<li><strong>要求：被代理类最少实现一个接口</strong></li>
</ul>
</li>
<li><strong>基于子类的动态代理</strong><ul>
<li><strong>提供者：第三方的CGLib</strong></li>
<li><strong>要求：被代理类不能用final修饰的类</strong>（最终类）。</li>
</ul>
</li>
</ul>
<p><em>下面将两种动态代理的方式分别演示一下</em></p>
<h5 id="使用JDK官方的Proxy类创建代理对象"><a href="#使用JDK官方的Proxy类创建代理对象" class="headerlink" title="使用JDK官方的Proxy类创建代理对象"></a>使用JDK官方的Proxy类创建代理对象</h5><p>这里我使用的是一个<strong>电脑厂商生产和销售电脑</strong>的例子：</p>
<ul>
<li>早期电脑<strong>厂商</strong>刚开始生产电脑时，销售大多是由厂商自己公司的销售人员进行，逐渐地规模越来越大，出现了一种连接消费者和厂商之间的人，称为代理商，<strong>代理商</strong>从厂家拿到产品，再加价买给<strong>用户</strong>。代理商越做越大，会提出一些要求，比如：厂家免费售后、厂家只能销售给代理商等等。<br><img src="/2020/03/18/Spring学习day03（Spring中的AOP）/2.png" alt="image"></li>
</ul>
<p><strong>下面用代码演示出来：</strong>（这里<strong>仅仅模拟代理的环节</strong>，其中的业务没有书写，<strong>其旨在理解代理的过程和动态代理的实现</strong>）</p>
<ul>
<li><p><strong>IProducer接口模拟代理商对厂家的要求</strong>（售后和销售价格）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对生产厂家要求的接口</span><br><span class="line"> */</span><br><span class="line">public interface IProducer &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 销售</span><br><span class="line">     * @param money</span><br><span class="line">     */</span><br><span class="line">    public void saleProduct(float money);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 售后</span><br><span class="line">     * @param money</span><br><span class="line">     */</span><br><span class="line">    public void afterService(float money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Producer实现类模拟厂家符合代理商的要求</strong>（售后和销售价格）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.cglib;</span><br><span class="line"></span><br><span class="line">import com.allen.proxy.IProducer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一个生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 销售</span><br><span class="line">     * @param money</span><br><span class="line">     */</span><br><span class="line">    public void saleProduct(float money)&#123;</span><br><span class="line">        System.out.println(&quot;销售产品，共拿到钱：&quot;+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 售后</span><br><span class="line">     * @param money</span><br><span class="line">     */</span><br><span class="line">    public void afterService(float money)&#123;</span><br><span class="line">        System.out.println(&quot;提供售后服务，并拿到钱：&quot;+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Client实体类模拟一个消费者</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.proxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  模拟一个消费者</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Producer producer = new Producer();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 动态代理：</span><br><span class="line">         *  特点：字节码随用随创建，随用随加载</span><br><span class="line">         *  作用：不修改源码的基础上对方法增强</span><br><span class="line">         *  分类：</span><br><span class="line">         *      基于接口的动态代理</span><br><span class="line">         *      基于子类的动态代理</span><br><span class="line">         *   基于接口的动态代理</span><br><span class="line">         *      涉及的类：Proxy</span><br><span class="line">         *      提供者：JDK官方</span><br><span class="line">         *   如何创建代理对象：</span><br><span class="line">         *      使用Proxy类中的newProxyInstance方法</span><br><span class="line">         *   创建代理对象的要求：</span><br><span class="line">         *      被代理类最少实现一个接口，如果没有则不能使用</span><br><span class="line">         *   newProxyInstance方法的参数：</span><br><span class="line">         *      ClassLoader：类加载器</span><br><span class="line">         *          它是用于加载代理对象字节码，和被代理对象使用相同的类加载器。固定写法</span><br><span class="line">         *      Class[]：字节码数组</span><br><span class="line">         *          它是用于让代理对象和被代理对象有相同方法</span><br><span class="line">         *      InvocationHandler：用于提供增强的代码</span><br><span class="line">         *          它是让我们写如何代理。我们一般都是写一个该接口的是实现类，通常情况下都是匿名内部类，但不是必须的</span><br><span class="line">         *          此接口的实现类都是谁用谁写</span><br><span class="line">         */</span><br><span class="line">        IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),</span><br><span class="line">                producer.getClass().getInterfaces(),</span><br><span class="line">                new InvocationHandler() &#123;</span><br><span class="line">                    /**</span><br><span class="line">                     * 作用：执行被代理对象的任何接口方法都会经过该方法</span><br><span class="line">                     * 方法参数的含义</span><br><span class="line">                     * @param proxy     代理对象的引用</span><br><span class="line">                     * @param method    当前执行的方法</span><br><span class="line">                     * @param args      当前执行方法所需的参数</span><br><span class="line">                     * @return          和被代理对象方法有相同的返回值</span><br><span class="line">                     * @throws Throwable</span><br><span class="line">                     */</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        //提供增强的代码</span><br><span class="line">                        Object returnValue = null;</span><br><span class="line">                        //1、获取方法执行的参数</span><br><span class="line">                        Float money = (Float)args[0];</span><br><span class="line">                        //2、判断当前方法是不是销售</span><br><span class="line">                        if(&quot;saleProduct&quot;.equals(method.getName()))&#123;</span><br><span class="line">                            returnValue = method.invoke(producer, money*0.8f);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return returnValue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        proxyProducer.saleProduct(10000f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="使用CGLib的Enhancer类创建代理对象"><a href="#使用CGLib的Enhancer类创建代理对象" class="headerlink" title="使用CGLib的Enhancer类创建代理对象"></a>使用CGLib的Enhancer类创建代理对象</h5><p><strong>首先需要导入CGLib的jar包</strong>，导入结果如下：<br><img src="/2020/03/18/Spring学习day03（Spring中的AOP）/3.png" alt="image"></p>
<p>在这里我创建的是一个<strong>普通的maven工程，pom.xml中添加以下依赖</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1_3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>如果使用创建普通的java工程，先导入CGLib的jar包，<em>如果报asmxxxx异常，需要导入asm.jar。</em></p>
<ul>
<li><p><strong>Producer实现类模拟厂家符合代理商的要求</strong>（售后和销售价格），<strong>不实现接口</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.cglib;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一个生产者</span><br><span class="line"> */</span><br><span class="line">public class Producer&#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 销售</span><br><span class="line">     * @param money</span><br><span class="line">     */</span><br><span class="line">    public void saleProduct(float money)&#123;</span><br><span class="line">        System.out.println(&quot;销售产品，共拿到钱：&quot;+money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 售后</span><br><span class="line">     * @param money</span><br><span class="line">     */</span><br><span class="line">    public void afterService(float money)&#123;</span><br><span class="line">        System.out.println(&quot;提供售后服务，并拿到钱：&quot;+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>现在继续模拟一个消费者Client</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.cglib;</span><br><span class="line"></span><br><span class="line">import com.allen.proxy.IProducer;</span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  模拟一个消费者</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Producer producer = new Producer();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 动态代理：</span><br><span class="line">         *  特点：字节码随用随创建，随用随加载</span><br><span class="line">         *  作用：不修改源码的基础上对方法增强</span><br><span class="line">         *  分类：</span><br><span class="line">         *      基于接口的动态代理</span><br><span class="line">         *      基于子类的动态代理</span><br><span class="line">         *   基于子类的动态代理</span><br><span class="line">         *      涉及的类：Enhancer</span><br><span class="line">         *      提供者：第三方cglib库</span><br><span class="line">         *   如何创建代理对象：</span><br><span class="line">         *      使用Enhancer类中的create方法</span><br><span class="line">         *   创建代理对象的要求：</span><br><span class="line">         *      被代理类不能是最终类</span><br><span class="line">         *   create方法的参数：</span><br><span class="line">         *      Class：字节码</span><br><span class="line">         *          它是用于指定被代理对象的字节码</span><br><span class="line">         *</span><br><span class="line">         *      Callback：用于提供增强的代码</span><br><span class="line">         *          它是让我们写如何代理。我们一般都是写一个该接口的是实现类，通常情况下都是匿名内部类，但不是必须的</span><br><span class="line">         *          此接口的实现类都是谁用谁写</span><br><span class="line">         *          我们一般写的都是该接口的子接口实现类，MethodInterceptor</span><br><span class="line">         */</span><br><span class="line">        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() &#123;</span><br><span class="line">            /**</span><br><span class="line">             * 执行被代理对象的任何方法都会经过该方法</span><br><span class="line">             * @param proxy</span><br><span class="line">             * @param method</span><br><span class="line">             * @param args</span><br><span class="line">             *      以上三个参数和基于接口的动态代理中invoke方法的参数是一样的</span><br><span class="line">             * @param methodProxy：当前执行方法的代理对象</span><br><span class="line">             * @return</span><br><span class="line">             * @throws Throwable</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                //提供增强的代码</span><br><span class="line">                Object returnValue = null;</span><br><span class="line">                //1、获取方法执行的参数</span><br><span class="line">                Float money = (Float) args[0];</span><br><span class="line">                //2、判断当前方法是不是销售</span><br><span class="line">                if (&quot;saleProduct&quot;.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money * 0.8f);</span><br><span class="line">                &#125;</span><br><span class="line">                return returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cglibProducer.saleProduct(12000f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我想在座的各位肯定会想到<strong>一个问题</strong>，通过这个模拟代理过程，<em>代理到底有什么意义？下面再回到一开始的账户转账的案例中来</em>。<strong>使用代理就能解绝刚才的事务管理问题，并且业务层代码不会出现像刚才一样臃肿。</strong></p>
<h4 id="（5）解决案例中的问题"><a href="#（5）解决案例中的问题" class="headerlink" title="（5）解决案例中的问题"></a>（5）解决案例中的问题</h4><p><em>废话不多说，直接上代码</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 用于创建客户业务层对象工厂（当然也可以创建其他业务层对象，只不过此处不做那么繁琐）</span><br><span class="line">*/</span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">    /**</span><br><span class="line">    * 创建账户业务层实现类的代理对象</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">    public static IAccountService getAccountService() &#123;</span><br><span class="line">        //1.定义被代理对象</span><br><span class="line">        final AccountService accountService = new AccountServiceImpl();</span><br><span class="line">        //2.创建代理对象</span><br><span class="line">        AccountService proxyAccountService = (AccountService)</span><br><span class="line">        Proxy.newProxyInstance(accountService.getClass().getClassLoader(),accountService.getClass().getInterfaces(),new nvocationHandler() &#123;</span><br><span class="line">            /**</span><br><span class="line">            * 执行被代理对象的任何方法，都会经过该方法。</span><br><span class="line">            * 此处添加事务控制</span><br><span class="line">            */</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, </span><br><span class="line">            Object[] args) throws Throwable &#123;</span><br><span class="line">                Object rtValue = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //开启事务</span><br><span class="line">                    TransactionManager.beginTransaction();</span><br><span class="line">                    //执行业务层方法</span><br><span class="line">                    rtValue = method.invoke(accountService, args);</span><br><span class="line">                    //提交事务</span><br><span class="line">                    TransactionManager.commit();</span><br><span class="line">                &#125;catch(Exception e) &#123;</span><br><span class="line">                    //回滚事务</span><br><span class="line">                    TransactionManager.rollback();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;finally &#123;</span><br><span class="line">                    //释放资源</span><br><span class="line">                    TransactionManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">                return rtValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return proxyAccountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当改造完成之后，业务层用于控制事务的重复代码就都可以删掉了。</strong></p>
<p><em>是不是感觉瞬间就不一样了呢？一直代理一直爽，有没有</em></p>
<p><strong>下面开始来说主角，Spring中的AOP，它可以做到只需要配置就能完成这些动态代理以及事务控制。</strong></p>
<h2 id="二、Spring中的AOP"><a href="#二、Spring中的AOP" class="headerlink" title="二、Spring中的AOP"></a>二、Spring中的AOP</h2><h3 id="1、Spring中AOP的细节"><a href="#1、Spring中AOP的细节" class="headerlink" title="1、Spring中AOP的细节"></a>1、Spring中AOP的细节</h3><p>学习Spring的AOP，就是<strong>通过配置的方式</strong>，<strong>实现</strong>刚才的<strong>功能</strong>。</p>
<h4 id="（1）AOP相关术语"><a href="#（1）AOP相关术语" class="headerlink" title="（1）AOP相关术语"></a>（1）AOP相关术语</h4><p><em>先了解一下，后面通过示例就可以明白其意</em></p>
<ul>
<li><strong>Joinpoint(连接点)</strong>:<ul>
<li><strong>所谓连接点是指那些被拦截到的点。在Spring中,这些点指的是方法,因为Spring只支持方法类型的<br>连接点。</strong></li>
</ul>
</li>
<li><strong>Pointcut(切入点)</strong>:<ul>
<li><strong>所谓切入点是指要对哪些Joinpoint进行拦截的定义。</strong></li>
<li><strong>例如</strong>：刚才的转账案例中IProducer接口中定义的方法，也就是<strong>要通过动态代理代理拦截进行加强的方法</strong>。</li>
</ul>
</li>
<li><strong>Advice(通知/增强)</strong>:<ul>
<li><strong>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。</strong></li>
<li><strong>例如</strong>：刚才的转账案例中BeanFactory的动态代理中引用的那几个方法，也就是<strong>实现动态代理中对方法进行增强的那几个方法</strong>。（<em>可能有些抽象，下面有一张图，一看便知</em>）</li>
<li><strong>通知的类型</strong>：<strong>前置通知,后置通知,异常通知,最终通知,环绕通知</strong><br><img src="/2020/03/18/Spring学习day03（Spring中的AOP）/4.png" alt="image"></li>
</ul>
</li>
<li><strong>Introduction(引介)</strong>:<ul>
<li><strong>引介是一种特殊的通知在不修改类代码的前提下,Introduction可以在运行期为类动态地添加一些方法或Field</strong>。（<em>在现在我这个比较菜的阶段不会用到这个东西，了解一下就行了</em>）</li>
</ul>
</li>
<li><strong>Target(目标对象)</strong>:<strong>代理的目标对象</strong>。（<em>没什么好说的</em>）</li>
<li><strong>Weaving(织入)</strong>:<ul>
<li><strong>织入是指把增强应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入</strong>，<em>而AspectJ采用编译期织入和类装载期织入</em>。</li>
<li>可以这样理解，<strong>原本在Service业务层中定义的方法不能实现事务管理</strong>，而<strong>在BeanFactory中通过动态代理来实现</strong>事务控制时，<strong>加入那些事务管理的方法（也就是刚说的通知）的过程就是Weaving（织入）</strong></li>
</ul>
</li>
<li><strong>Proxy（代理）</strong>:<strong>一个类被AOP织入增强后，就产生一个结果代理类。</strong></li>
<li><strong>Aspect(切面)</strong>:<strong>是切入点和通知（引介）的结合</strong>。（<em>个人理解就是BeanFactory中通过动态代理增强方法后得到的能够实现整个事务控制的方法</em>）</li>
</ul>
<h4 id="（2）学习Spring中的AOP要明确的事"><a href="#（2）学习Spring中的AOP要明确的事" class="headerlink" title="（2）学习Spring中的AOP要明确的事"></a>（2）学习Spring中的AOP要明确的事</h4><ul>
<li><strong>开发阶段</strong><ul>
<li><strong>编写核心业务代码（开发主线）</strong>（大部分程序员来做，要求熟悉业务需求）</li>
<li><strong>把公用代码抽取出来，制作成通知。（开发阶段最后再做）</strong>（AOP编程人员来做）—</li>
<li><strong>在配置文件中，声明切入点与通知间的关系，即切面。</strong>（AOP编程人员来做）</li>
<li><strong>现在是学习阶段，所有操作都是我们自己做</strong></li>
</ul>
</li>
<li><strong>运行阶段（Spring框架完成的）</strong><ul>
<li><strong>Spring框架监控切入点方法的执行</strong>。一旦监控到切入点方法<strong>被运行，使用代理机制，动态创建目标对象的代理对象</strong>，<strong>根据通知类别，在代理对象的对应位置，将通知对应的功能织入</strong>，完成完整的代码逻辑运行。</li>
</ul>
</li>
</ul>
<h4 id="（3）关于代理的选择"><a href="#（3）关于代理的选择" class="headerlink" title="（3）关于代理的选择"></a>（3）关于代理的选择</h4><p><strong>在Spring中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</strong></p>
<h3 id="2、基于XML的AOP配置"><a href="#2、基于XML的AOP配置" class="headerlink" title="2、基于XML的AOP配置"></a>2、基于XML的AOP配置</h3><p><em>在进行配置以学习使用Spring的AOP时，选用的示例是模拟账户操作（CRUD操作用打印语句代替，旨在掌握Spring的AOP如何使用和配置）</em></p>
<h4 id="（1）环境搭建"><a href="#（1）环境搭建" class="headerlink" title="（1）环境搭建"></a>（1）环境搭建</h4><h5 id="第一步：创建普通maven工程导入jar包（坐标）"><a href="#第一步：创建普通maven工程导入jar包（坐标）" class="headerlink" title="第一步：创建普通maven工程导入jar包（坐标）"></a>第一步：创建普通maven工程导入jar包（坐标）</h5><p><strong>直接选择maven工程不需要选择模板直接创建，添加需要导入的依赖jar包坐标</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打包方式--&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;!--所需依赖jar包--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring的jar--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--切入点表达式的jar包，后面会用到--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.8.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><em>创建普通的java工程也可以，导入jar包即可，这里使用maven是因为比较方便，并且后期做项目都会使用到maven</em></p>
<h5 id="第二步：准备必要的代码"><a href="#第二步：准备必要的代码" class="headerlink" title="第二步：准备必要的代码"></a>第二步：准备必要的代码</h5><p><em>此处包含了实体类业务层代码，都只是在模拟实现操作，所以也没必要加入持久层代码</em></p>
<ul>
<li><p><strong>业务层接口AccountService</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.service;</span><br><span class="line">/**</span><br><span class="line"> * 账户的业务层接口</span><br><span class="line"> */</span><br><span class="line">public interface AccountService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 模拟保存账户</span><br><span class="line">      */</span><br><span class="line">    void saveAccount();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 模拟更新账户</span><br><span class="line">     * @param i</span><br><span class="line">     */</span><br><span class="line">    void updateAccount(int i);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除账户</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    int deleteAccount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>业务层接口实现类AccountServiceImpl</strong>（<em>重要的事说三遍，我实在模拟操作，不喜勿喷哈</em>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.service.impl;</span><br><span class="line"></span><br><span class="line">import com.allen.service.AccountService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 账户的业务层实现类</span><br><span class="line"> */</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;执行了保存&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void updateAccount(int i) &#123;</span><br><span class="line">        System.out.println(&quot;执行了更新&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int deleteAccount() &#123;</span><br><span class="line">        System.out.println(&quot;执行了删除&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="第三步：创建Spring的配置文件并导入约束"><a href="#第三步：创建Spring的配置文件并导入约束" class="headerlink" title="第三步：创建Spring的配置文件并导入约束"></a>第三步：创建Spring的配置文件并导入约束</h5><p><strong>在Resource目录下创建bean.xml配置文件，配置如下内容（Spring配置所需的约束）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">     http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">     http://www.springframework.org/schema/aop</span><br><span class="line">     http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第四步：配置Spring的IOC"><a href="#第四步：配置Spring的IOC" class="headerlink" title="第四步：配置Spring的IOC"></a>第四步：配置Spring的IOC</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置spring的IOC，把service对象配置起来--&gt;</span><br><span class="line">    &lt;bean id=&quot;accountService&quot; class=&quot;com.allen.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第五步：抽取公共代码制作成通知"><a href="#第五步：抽取公共代码制作成通知" class="headerlink" title="第五步：抽取公共代码制作成通知"></a>第五步：抽取公共代码制作成通知</h5><ul>
<li><em>这里模拟得比较简单，旨在理解配置过程</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.utils;</span><br><span class="line">/**</span><br><span class="line"> * 用于记录日志的工具类，它里面提供了公共代码</span><br><span class="line"> */</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 前置通知</span><br><span class="line">     */</span><br><span class="line">    public void beforePrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后置通知</span><br><span class="line">     */</span><br><span class="line">    public void afterReturningPrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常通知</span><br><span class="line">     */</span><br><span class="line">    public void afterThrowingPrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 最终通知</span><br><span class="line">     */</span><br><span class="line">    public void afterPrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="（2）配置步骤"><a href="#（2）配置步骤" class="headerlink" title="（2）配置步骤"></a>（2）配置步骤</h4><h5 id="第一步：把通知类用bean标签配置起来"><a href="#第一步：把通知类用bean标签配置起来" class="headerlink" title="第一步：把通知类用bean标签配置起来"></a>第一步：把通知类用<code>bean</code>标签配置起来</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Logger类--&gt;</span><br><span class="line">    &lt;bean id=&quot;logger&quot; class=&quot;com.allen.utils.Logger&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第二步：使用aop-config声明AOP配置"><a href="#第二步：使用aop-config声明AOP配置" class="headerlink" title="第二步：使用aop:config声明AOP配置"></a>第二步：使用<code>aop:config</code>声明AOP配置</h5><ul>
<li><strong><code>aop:config</code>:</strong><ul>
<li><strong>作用：用于声明开始AOP的配置</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 配置的代码都写在此处 --&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="第三步：使用aop-aspect配置切面"><a href="#第三步：使用aop-aspect配置切面" class="headerlink" title="第三步：使用aop:aspect配置切面"></a>第三步：使用<code>aop:aspect</code>配置切面</h5><ul>
<li><p><strong><code>aop:aspect</code>:</strong></p>
<ul>
<li><p><strong>作用：用于配置切面。</strong></p>
</li>
<li><p><strong>属性</strong>：</p>
<p>属性名 | 含义</p>
</li>
</ul>
<p>  —|—<br>  id | 给切面提供一个唯一标识<br>  ref | 引用配置好的通知类bean的id</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置切面--&gt;</span><br><span class="line">&lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置通知的类型要写在此处--&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/aop:aspect&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第四步：使用aop-pointcut配置切入点表达式"><a href="#第四步：使用aop-pointcut配置切入点表达式" class="headerlink" title="第四步：使用aop:pointcut配置切入点表达式"></a>第四步：使用<code>aop:pointcut</code>配置切入点表达式</h5><ul>
<li><p><strong><code>aop:pointcut</code></strong>：</p>
<ul>
<li><p><strong>作用：用于配置切入点表达式。</strong> <em>就是指定对哪些类的哪些方法进行增强</em></p>
</li>
<li><p><strong>属性</strong>：</p>
<p>属性名 | 含义</p>
</li>
</ul>
<p>  —|—<br>  expression | 用于定义切入点表达式<br>  id | 用于给切入点表达式提供一个唯一标识</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置切入点表达式，id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span><br><span class="line">                此标签写在aop:aspect标签内部只能当前切面使用。</span><br><span class="line">                它还可以写在aop:aspect外面，此时就变成了所有切面可用</span><br><span class="line">            --&gt;</span><br><span class="line">&lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.allen.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第五步：使用aop-xxx配置对应的通知类型"><a href="#第五步：使用aop-xxx配置对应的通知类型" class="headerlink" title="第五步：使用aop:xxx配置对应的通知类型"></a>第五步：使用<code>aop:xxx</code>配置对应的通知类型</h5><ul>
<li><p><strong><code>aop:before</code></strong></p>
<ul>
<li><p><strong>作用：用于配置前置通知</strong>。<em>指定增强的方法在切入点方法之前执行</em></p>
</li>
<li><p><strong>属性</strong>：</p>
<p>属性名 | 含义</p>
</li>
</ul>
<p>  —|—<br>  method | 用于指定通知类中的增强方法名称<br>  ponitcut-ref | 用于指定切入点的表达式的引用<br>  poinitcut | 用于指定切入点表达式</p>
<ul>
<li><strong>执行时间点</strong>：<strong>切入点方法执行之前执行</strong></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置前置通知：在切入点方法执行之前执行--&gt;</span><br><span class="line">&lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>aop:after-returning</code></strong></p>
<ul>
<li><p><strong>作用：用于配置后置通知</strong></p>
</li>
<li><p><strong>属性</strong>：</p>
<p>属性名 | 含义</p>
</li>
</ul>
<p>  —|—<br>  method | 指定通知中方法的名称<br>  ponitcut-ref | 指定切入点表达式的引用<br>  pointcut | 定义切入点表达式</p>
<ul>
<li><strong>执行时间点</strong>：<strong>切入点方法正常执行之后</strong>。==<strong>它和异常通知只能有一个执行</strong>==</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置后置通知：在切入点正常执行之后执行。它和异常通知永远只能执行一个--&gt;</span><br><span class="line">&lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>aop:after-throwing</code></strong></p>
<ul>
<li><p><strong>作用：用于配置异常通知</strong></p>
</li>
<li><p><strong>属性</strong>：</p>
<p>属性名 | 含义</p>
</li>
</ul>
<p>  —|—<br>  method | 指定通知中方法的名称<br>  ponitcut-ref | 指定切入点表达式的引用<br>  pointcut | 定义切入点表达式</p>
<ul>
<li><strong>执行时间点：切入点方法执行产生异常后执行。</strong> ==<strong>它和后置通知只能执行一个</strong>==</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置异常通知：在切入点执行产生异常之后执行。它和后置通知永远只能执行一个--&gt;</span><br><span class="line">&lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong><code>aop:after</code></strong></p>
<ul>
<li><p><strong>作用：用于配置最终通知</strong></p>
</li>
<li><p><strong>属性</strong>：</p>
<p>属性名 | 含义</p>
</li>
</ul>
<p>  —|—<br>  method | 指定通知中方法的名称<br>  ponitcut-ref | 指定切入点表达式的引用<br>  pointcut | 定义切入点表达式</p>
<ul>
<li><strong>执行时间点：无论切入点方法执行时是否有异常，它都会在其后面执行。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!--配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt;</span><br><span class="line">&lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="（3）配置完成后的bean-xml"><a href="#（3）配置完成后的bean-xml" class="headerlink" title="（3）配置完成后的bean.xml"></a>（3）配置完成后的bean.xml</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line">    &lt;!--配置spring的IOC，把service对象配置起来--&gt;</span><br><span class="line">    &lt;bean id=&quot;accountService&quot; class=&quot;com.allen.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置Logger类--&gt;</span><br><span class="line">    &lt;bean id=&quot;logger&quot; class=&quot;com.allen.utils.Logger&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置AOP--&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;!--配置切入点表达式，id属性用于指定表达式的唯一标识。expression属性用于指定表达式内容</span><br><span class="line">                此标签写在aop:aspect标签内部只能当前切面使用。</span><br><span class="line">                它还可以写在aop:aspect外面，此时就变成了所有切面可用</span><br><span class="line">            --&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.allen.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br><span class="line">        &lt;!--配置切面--&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;</span><br><span class="line">            &lt;!--配置前置通知：在切入点方法执行之前执行--&gt;</span><br><span class="line">            &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--配置后置通知：在切入点正常执行之后执行。它和异常通知永远只能执行一个--&gt;</span><br><span class="line">            &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-returning&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--配置异常通知：在切入点执行产生异常之后执行。它和后置通知永远只能执行一个--&gt;</span><br><span class="line">            &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after-throwing&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--配置最终通知：无论切入点方法是否正常执行它都会在其后面执行--&gt;</span><br><span class="line">            &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:after&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（4）切入点表达式说明"><a href="#（4）切入点表达式说明" class="headerlink" title="（4）切入点表达式说明"></a>（4）切入点表达式说明</h4><p><strong>==execution==:匹配方法的执行(常用)</strong></p>
<ul>
<li><code>execution(表达式)</code></li>
<li><strong>表达式语法：<code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></strong></li>
<li><strong>写法说明</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>各种写法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>标准的表达式写法</td>
<td><code>public void com.allen.service.impl.AccountServiceImpl.saveAccount()</code></td>
</tr>
<tr>
<td>访问修饰符可以省略</td>
<td><code>void com.allen.service.impl.AccountServiceImpl.saveAccount()</code></td>
</tr>
<tr>
<td>返回值可以使用通配符，表示任意返回值</td>
<td><code>* com.allen.service.impl.AccountServiceImpl.saveAccount()</code></td>
</tr>
<tr>
<td>包名可以使用通配符，表示任意包，有几级包，就需要写几个<code>*.</code></td>
<td><code>* *.*.*.*.AccountServiceImpl.saveAccount()</code></td>
</tr>
<tr>
<td>包名可以使用<code>..</code>表示当前包及其子包</td>
<td><code>* *..AccountServiceImpl.saveAccount()</code></td>
</tr>
<tr>
<td>类名和方法名都可以使用<code>*</code>来实现通配</td>
<td><code>* *..*.*()</code></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>参数列表</strong>：</p>
<ul>
<li><strong>可以直接写数据类型</strong><ul>
<li><strong>基本类型直接写名称</strong>，例如：<code>int</code></li>
<li><strong>引用类型写<code>包名.类名</code>的方式</strong>，例如：<code>java.lang.String</code></li>
</ul>
</li>
<li><strong>可以使用通配符表示任意类型，但是必须有参数</strong></li>
<li><strong>可以使用<code>..</code>表示有无参数均可，有参数可以是任意类型</strong></li>
</ul>
</li>
<li><p><strong>全通配写法</strong>：<code>* *..*.*(..)</code></p>
</li>
<li><p><strong>==实际开发中切入点表达式的通常写法==</strong></p>
<ul>
<li><strong>切入到业务层实现类下的所有方法</strong> ：<code>* com.allen.service.impl.*.*(..)</code></li>
</ul>
</li>
</ul>
<h4 id="（5）环绕通知"><a href="#（5）环绕通知" class="headerlink" title="（5）环绕通知"></a>（5）环绕通知</h4><h5 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置AOP--&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--配置切入点表达式--&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.allen.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</span><br><span class="line">    &lt;!--配置切面--&gt;</span><br><span class="line">    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;</span><br><span class="line">        &lt;!--配置环绕通知 详细的注释请看Logger类中--&gt;</span><br><span class="line">        &lt;aop:around method=&quot;aroundPrintLog&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:around&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<h5 id="aop-around"><a href="#aop-around" class="headerlink" title="aop:around"></a><code>aop:around</code></h5><ul>
<li><strong>作用：用于配置环绕通知</strong></li>
<li><strong>属性</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>method</td>
<td>指定通知中方法的名称</td>
</tr>
<tr>
<td>ponitcut-ref</td>
<td>指定切入点表达式的引用</td>
</tr>
<tr>
<td>pointcut</td>
<td>定义切入点表达式</td>
</tr>
</tbody></table>
<ul>
<li><strong>说明</strong>：<strong>它是Spring框架提供的一种可以在代码中手动控制增强代码什么时候执行的方式。</strong></li>
<li><strong>注意</strong>：<strong>通常情况下，环绕通知都是独立使用的</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.utils;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于记录日志的工具类，它里面提供了公共代码</span><br><span class="line"> */</span><br><span class="line">public class Logger &#123;</span><br><span class="line"> /**</span><br><span class="line">     * 环绕通知</span><br><span class="line">     * 问题：</span><br><span class="line">     *      当我们配置了环绕通知之后，切入点没有执行，而通知方法执行了</span><br><span class="line">     * 分析：</span><br><span class="line">     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有</span><br><span class="line">     * 解决：</span><br><span class="line">     *      Spring框架为我们提供了一个接口，ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。</span><br><span class="line">     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</span><br><span class="line">     * spring中的环绕通知：</span><br><span class="line">     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span><br><span class="line">     */</span><br><span class="line">    public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">        Object rtValue = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] args = pjp.getArgs();//得到方法执行所需的参数</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。前置&quot;);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。后置&quot;);</span><br><span class="line"></span><br><span class="line">            return rtValue;</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。异常&quot;);</span><br><span class="line">            throw new RuntimeException(throwable);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。最终&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、基于注解的AOP配置"><a href="#3、基于注解的AOP配置" class="headerlink" title="3、基于注解的AOP配置"></a>3、基于注解的AOP配置</h3><h4 id="（1）环境搭建-1"><a href="#（1）环境搭建-1" class="headerlink" title="（1）环境搭建"></a>（1）环境搭建</h4><h5 id="第一步：创建普通maven工程导入jar包（坐标）-1"><a href="#第一步：创建普通maven工程导入jar包（坐标）-1" class="headerlink" title="第一步：创建普通maven工程导入jar包（坐标）"></a>第一步：创建普通maven工程导入jar包（坐标）</h5><p><strong>直接选择maven工程不需要选择模板直接创建，添加需要导入的依赖jar包坐标</strong>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--打包方式--&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">&lt;!--所需依赖jar包--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--spring的jar--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--切入点表达式的jar包，后面会用到--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.8.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><em>创建普通的java工程也可以，导入jar包即可，这里使用maven是因为比较方便，并且后期做项目都会使用到maven</em></p>
<h5 id="第二步：准备必要的代码-1"><a href="#第二步：准备必要的代码-1" class="headerlink" title="第二步：准备必要的代码"></a>第二步：准备必要的代码</h5><p><em>拷贝刚才基于XML配置中的案例的接口和实体类业务层代码</em></p>
<h5 id="第三步：在配置文件中导入context的名称空间"><a href="#第三步：在配置文件中导入context的名称空间" class="headerlink" title="第三步：在配置文件中导入context的名称空间"></a>第三步：在配置文件中导入context的名称空间</h5><p><strong>在Resource目录下创建bean.xml配置文件，配置如下内容（Spring注解配置所需的约束）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第四步：把资源使用注解配置"><a href="#第四步：把资源使用注解配置" class="headerlink" title="第四步：把资源使用注解配置"></a>第四步：把资源使用注解配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.service.impl;</span><br><span class="line"></span><br><span class="line">import com.allen.service.AccountService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 账户的业务层实现类</span><br><span class="line"> */</span><br><span class="line">@Service(&quot;accountService&quot;)</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">   //中间操作此处省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第五步：在bean-xml配置文件中指定Spring要扫描的包"><a href="#第五步：在bean-xml配置文件中指定Spring要扫描的包" class="headerlink" title="第五步：在bean.xml配置文件中指定Spring要扫描的包"></a>第五步：在bean.xml配置文件中指定Spring要扫描的包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置spring创建容器时要扫描的包--&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.allen&quot;&gt;&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<h4 id="（2）配置步骤-1"><a href="#（2）配置步骤-1" class="headerlink" title="（2）配置步骤"></a>（2）配置步骤</h4><h5 id="第一步：在bean-xml配置文件中开启Spring对注解AOP的支持"><a href="#第一步：在bean-xml配置文件中开启Spring对注解AOP的支持" class="headerlink" title="第一步：在bean.xml配置文件中开启Spring对注解AOP的支持"></a>第一步：在bean.xml配置文件中开启Spring对注解AOP的支持</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置spring开启注解AOP的支持--&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure>

<h5 id="第二步：通知类使用注解配置并使用-Aspect注解声明为切面"><a href="#第二步：通知类使用注解配置并使用-Aspect注解声明为切面" class="headerlink" title="第二步：通知类使用注解配置并使用@Aspect注解声明为切面"></a>第二步：通知类使用注解配置并使用<code>@Aspect</code>注解声明为切面</h5><ul>
<li><strong>作用</strong>：<strong>把当前类声明为切面类</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.utils;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于记录日志的工具类，它里面提供了公共代码</span><br><span class="line"> */</span><br><span class="line">@Component(&quot;logger&quot;)</span><br><span class="line">@Aspect//表示当前类是一个切面类</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    //操作代码部分此处省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="第三步：在增强的方法上使用注解配置通知"><a href="#第三步：在增强的方法上使用注解配置通知" class="headerlink" title="第三步：在增强的方法上使用注解配置通知"></a>第三步：在增强的方法上使用注解配置通知</h5><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Before</code></td>
<td>把当前方法看成是<strong>前置</strong>通知</td>
<td><strong>value</strong>：用于指定切入点表达式，还可以指定切入点表达式的引用。</td>
</tr>
<tr>
<td><code>@AfterReturning</code></td>
<td>把当前方法看成是<strong>后置</strong>通知</td>
<td><strong>value</strong>：用于指定切入点表达式，还可以指定切入点表达式的引用。</td>
</tr>
<tr>
<td><code>@AfterThrowing</code></td>
<td>把当前方法看成是<strong>异常</strong>通知</td>
<td><strong>value</strong>：用于指定切入点表达式，还可以指定切入点表达式的引用。</td>
</tr>
<tr>
<td><code>@After</code></td>
<td>把当前方法看成是<strong>最终</strong>通知</td>
<td><strong>value</strong>：用于指定切入点表达式，还可以指定切入点表达式的引用。</td>
</tr>
</tbody></table>
<p><strong>注解配置通知后的代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.utils;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于记录日志的工具类，它里面提供了公共代码</span><br><span class="line"> */</span><br><span class="line">@Component(&quot;logger&quot;)</span><br><span class="line">@Aspect//表示当前类是一个切面类</span><br><span class="line">public class Logger &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 前置通知</span><br><span class="line">     */</span><br><span class="line">    @Before(&quot;execution(* com.allen.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void beforePrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;前置通知Logger类中的beforePrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 后置通知</span><br><span class="line">     */</span><br><span class="line">    @AfterReturning(&quot;execution(* com.allen.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void afterReturningPrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;后置通知Logger类中的afterReturningPrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 异常通知</span><br><span class="line">     */</span><br><span class="line">    @AfterThrowing(&quot;execution(* com.allen.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void afterThrowingPrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 最终通知</span><br><span class="line">     */</span><br><span class="line">    @After(&quot;execution(* com.allen.service.impl.*.*(..))&quot;)</span><br><span class="line">    public void afterPrintLog()&#123;</span><br><span class="line">        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志了。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<strong>使用这些注解配置，后置注解<code>@AfterReturning</code>和最终注解<code>@After</code>并不能像我们想象的那样</strong>（<em>先执行后置注解<code>@AfterReturning</code>注解的方法，再执行最终注解<code>@After</code>注解的方法</em>），<strong>而是先执行最终注解<code>@After</code>注解的方法，再执行后置注解<code>@AfterReturning</code>注解的方法。</strong> <strong>这是由于框架内部就是这样实现的，顺序上有问题。</strong></li>
</ul>
<p><strong>下面介绍一种不会出现此类情况的注解配置</strong></p>
<h4 id="（3）环绕通知注解配置"><a href="#（3）环绕通知注解配置" class="headerlink" title="（3）环绕通知注解配置"></a>（3）环绕通知注解配置</h4><h5 id="Around"><a href="#Around" class="headerlink" title="@Around"></a><code>@Around</code></h5><ul>
<li><strong>作用：把当前方法看成是环绕通知</strong></li>
<li><strong>属性</strong>：<ul>
<li><strong>value：用于指定切入点表达式，还可以指定切入点表达式的引用。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.allen.utils;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.*;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用于记录日志的工具类，它里面提供了公共代码</span><br><span class="line"> */</span><br><span class="line">@Component(&quot;logger&quot;)</span><br><span class="line">@Aspect//表示当前类是一个切面类</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 环绕通知</span><br><span class="line">     * 问题：</span><br><span class="line">     *      当我们配置了环绕通知之后，切入点没有执行，而通知方法执行了</span><br><span class="line">     * 分析：</span><br><span class="line">     *      通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有</span><br><span class="line">     * 解决：</span><br><span class="line">     *      Spring框架为我们提供了一个接口，ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法。</span><br><span class="line">     *      该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用。</span><br><span class="line">     * spring中的环绕通知：</span><br><span class="line">     *      它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span><br><span class="line">     */</span><br><span class="line">    @Around(&quot;execution(* com.allen.service.impl.*.*(..))&quot;)</span><br><span class="line">    public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">        Object rtValue = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object[] args = pjp.getArgs();//得到方法执行所需的参数</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。前置&quot;);</span><br><span class="line"></span><br><span class="line">            rtValue = pjp.proceed(args);//明确调用业务层方法（切入点方法）</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。后置&quot;);</span><br><span class="line"></span><br><span class="line">            return rtValue;</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。异常&quot;);</span><br><span class="line">            throw new RuntimeException(throwable);</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            System.out.println(&quot;Logger类中的aroundPrintLog方法开始记录日志了。。。最终&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="（4）切入点表达式注解"><a href="#（4）切入点表达式注解" class="headerlink" title="（4）切入点表达式注解"></a>（4）切入点表达式注解</h4><h5 id="Pointcut"><a href="#Pointcut" class="headerlink" title="@Pointcut"></a><code>@Pointcut</code></h5><ul>
<li><p><strong>作用：指定切入点表达式</strong></p>
</li>
<li><p><strong>属性：value：指定表达式的内容</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* com.allen.service.impl.*.*(..))&quot;)</span><br><span class="line">private void pt1() &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用方式</strong>（<em>上面用哪四种注解进行配置和使用环绕通知注解进行配置都可以引用</em>，<strong>这里以环绕通知注解配置为例</strong>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Around(&quot;pt1()&quot;)//注意：千万别忘了写括号</span><br><span class="line">public Object aroundPrintLog(ProceedingJoinPoint pjp)&#123;</span><br><span class="line">    //内部控制代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="（5）完全不使用XML的配置方式"><a href="#（5）完全不使用XML的配置方式" class="headerlink" title="（5）完全不使用XML的配置方式"></a>（5）完全不使用XML的配置方式</h4><p><strong>将创建容器时要扫描的包以及开启注解AOP的支持都使用注解配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages=&quot;com.allen&quot;)</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    //内部控制代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>配到这里就可以彻底删除bean.xml的配置文件了，使用纯注解的方式</em></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Allen Xue</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span><strong>To be or not to be,that is a question.<strong></strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/Java-EE/"># Java_EE</a>
                    
                        <a href="/tag/Spring/"># Spring</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/03/16/Spring学习day02（基于注解的IOC配置、Spring整合Junit）/">Spring学习day02（基于注解的IOC配置、Spring整合Junit）</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Allen Xue | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
    
        <script type="text/javascript" color="0,0,0" opacity="0.3" zindex="-2" count="99" src="/js/canvas-nest.js"></script>
    
</body>
</html>
